<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Forest Inventory – Offline</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
body { margin:0; font-family:system-ui,sans-serif; background:#f4f6f5; }
header { background:#2f6f4e; color:#fff; padding:10px; display:flex; gap:10px; }
header button { background:rgba(255,255,255,.2); border:none; color:#fff; padding:6px 10px; border-radius:4px; }
header strong { align-items: center;}
main { padding:12px; }
.card { background:#fff; padding:12px; border-radius:8px; margin-bottom:10px; border:1px solid #ddd; }
.grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(260px,1fr)); gap:10px; }
.form-row { display: flex; gap: 8px; }
button { padding:6px 10px; border:none; border-radius:4px; background:#4f8f6f; color:#fff; cursor:pointer; }
button.danger { background:#c0392b; }
button.secondary { background:#777; }
input, textarea { box-sizing: border-box; width:100%; margin:4px 0; padding:6px; }
table { width:100%; border-collapse:collapse; }
th, td { border:1px solid #ccc; padding:6px; text-align:left; }
td { background:#fff; }
td[contenteditable] { background:#fdfefe; }
.actions { display:flex; gap:6px; flex-wrap:wrap; margin-top:6px; }
#map { box-sizing: border-box; height:450px; width:100%; margin-top:10px; }
.hidden { display:none; }
</style>
</head>

<body>

<header>
  <button id="backBtn" class="hidden">◀ Back</button>
  <strong id="title">Units</strong>
</header>

<main id="app"></main>

<script>
/* ============================================================
   IndexedDB
============================================================ */
const DB_NAME = "forest_inventory_db";
const DB_VERSION = 2;
let db;

function uid() {
    return crypto.randomUUID();
}

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = e => {
      db = e.target.result;
      db.createObjectStore("units", { keyPath: "id" });
    };
    req.onsuccess = e => { db = e.target.result; resolve(); };
  });
    req.onerror = e => reject(e.target.error);
}

function tx(store, mode="readonly") {
  return db.transaction(store, mode).objectStore(store);
}

function idbRequest(req) {
  return new Promise((resolve, reject) => {
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

// DB helper functions
const dbGet = (store, key) => idbRequest(tx(store).get(key));
const dbGetAll = store => idbRequest(tx(store).getAll());
const dbPut = (store, val) => idbRequest(tx(store,"readwrite").put(val));
const dbAdd = (store, val) => idbRequest(tx(store,"readwrite").add(val));
const dbDel = (store, key) => idbRequest(tx(store,"readwrite").delete(key));

function debounce(func, delay) {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
    };
}


/* ============================================================
   State & Navigation
============================================================ */
let nav = { view:"units" };
const app = document.getElementById("app");
const title = document.getElementById("title");
const backBtn = document.getElementById("backBtn");

backBtn.onclick = () => { nav = nav.prev; render(); };

function setView(v) { nav = {...v, prev:nav}; render(); }

/* ============================================================
   Rendering
============================================================ */
/*
  A simple helper to create an element with attributes and content.
  e.g., createEl("div", { className: "card" }, "Hello")
*/
const createEl = (tag, attrs = {}, ...children) => {
    const el = document.createElement(tag);
    Object.assign(el, attrs);
    el.append(...children);
    return el;
};

/* ============================================================
   Rendering
============================================================ */
async function render() {
  app.innerHTML = "";
  backBtn.classList.toggle("hidden", nav.view === "units");

  if (nav.view === "units") renderUnits();
  if (nav.view === "unit") renderUnit();
  if (nav.view === "plots") renderPlots();
  if (nav.view === "designs") renderDesigns();
  if (nav.view === "trees") renderTrees();
  if (nav.view === "logs") renderLogs();
}

/* ============================================================
   Units
============================================================ */
async function renderUnits() {
  title.textContent = "Units";
  const units = await dbGetAll("units");

  const grid = createEl("div", { className: "grid" });

  units.forEach(p => {
    grid.appendChild(
      createEl("div", {
        className: "card",
        onclick: () => setView({view:"unit", id:p.id})
      },
        createEl("h3", {}, p.name || "Unnamed Unit"),
        createEl("h3", {}, p.project_name || "Unnamed Project"),
        createEl("small", {}, `${p.plots.length} plots`)
      )
    );
  });

  const add = createEl("button", {
    textContent: "+ New Unit",
    onclick: async () => {
      const unit = { id: uid(), name: "", project_id: "", project_name: "", notes: "", polygon: null, plots: [], designs: [] };
      await dbAdd("units", unit);
      render();
    }
  });

  app.append(grid, add);
}

/* ============================================================
   Unit + Geometry Editor
============================================================ */
async function renderUnit() {
  title.textContent = "Unit";
  const p = await dbGet("units", nav.id);

  app.innerHTML = `
    <div class="form-row">
      <input placeholder="Unit Name" value="${p.name}">
      <input placeholder="Project Name" value="${p.project_name}">
      <input placeholder="Project ID" value="${p.project_id}">
    </div>
    <textarea placeholder="Notes...">${p.notes}</textarea>
    <div id="map"></div>
    <div class="actions">
      <button id="plotsBtn">Plots</button>
      <button id="designsBtn">Designs</button>
      <button id="drawBtn" class="secondary">Draw Polygon</button>
      <button id="clearBtn" class="secondary">Clear Polygon</button>
      <button id="exportJSON">Export JSON</button>
      <button id="exportCSV">Export CSV</button>
      <button class="danger" id="del">Delete</button>
    </div>
  `;

  const debouncedSave = debounce(() => dbPut("units", p), 500);
  const [nameInput, projectNameInput, projectIdInput, notesTextarea] = app.querySelectorAll("input,textarea");

  const onInput = () => {
    p.name = nameInput.value;
    p.project_name = projectNameInput.value;
    p.project_id = projectIdInput.value;
    p.notes = notesTextarea.value;
    debouncedSave();
  };
  nameInput.oninput = projectNameInput.oninput = projectIdInput.oninput = notesTextarea.oninput = onInput;

  initMap(p);

  document.getElementById("plotsBtn").onclick =
    () => setView({view:"plots", id:p.id});

  document.getElementById("designsBtn").onclick =
    () => setView({view:"designs", id:p.id});

  document.getElementById("del").onclick = async () => {
    if(confirm("Delete unit?")) {
      dbDel("units", p.id);
      nav = {view:"units"};
      render();
    }
  };

  document.getElementById("exportJSON").onclick = () => exportJSON(p);
  document.getElementById("exportCSV").onclick = () => exportCSV(p);
}

/* ============================================================
   Geometry Map Editor
============================================================ */
let map; // Make map instance available outside the function
function initMap(p) {
  if (map) map.remove();
  // Reassign the global map variable
  map = L.map("map").setView([45.9336, -120.5583], 6);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);

  let polygon;
  if(p.polygon) {
    polygon = L.geoJSON(p.polygon).addTo(map);
    map.fitBounds(polygon.getBounds());
  }

  let isDrawing = false;
  const drawBtn = document.getElementById("drawBtn");

  drawBtn.onclick = () => {
    isDrawing = !isDrawing;
    drawBtn.classList.toggle("secondary", !isDrawing);
    drawBtn.textContent = isDrawing ? "Finish Drawing" : "Draw Polygon";
  };

  document.getElementById("clearBtn").onclick = () => {
    if (polygon) {
      map.removeLayer(polygon);
      polygon = null;
      p.polygon = null;
      dbPut("units", p);
    }
  };

  map.on("click", e => {
    if (!isDrawing) return;
    const latlng = [e.latlng.lat, e.latlng.lng];
    if (!polygon) polygon = L.polygon([latlng]).addTo(map);
    else polygon.addLatLng(latlng);
    p.polygon = polygon.toGeoJSON();
    dbPut("units", p);
  });
}

/* ============================================================
   Plots
============================================================ */
async function renderPlots() {
  title.textContent = "Plots";
  const p = await dbGet("units", nav.id);
  
  const debouncedSave = debounce(() => dbPut("units", p), 500);

  p.plots.forEach(plot => {
    const inputs = {
        name: createEl("input", { placeholder: "Plot ID", value: plot.name || "" }),
        planned_lat: createEl("input", { placeholder: "Planned Lat", value: plot.planned_lat || "" }),
        planned_lon: createEl("input", { placeholder: "Planned Lon", value: plot.planned_lon || "" }),
        gps_lat: createEl("input", { placeholder: "GPS Lat", value: plot.gps_lat || "" }),
        gps_lon: createEl("input", { placeholder: "GPS Lon", value: plot.gps_lon || "" }),
    };

    for (const key in inputs) {
        inputs[key].oninput = () => {
            plot[key] = inputs[key].value;
            debouncedSave();
        };
    }

    const getGPS = () => {
        navigator.geolocation.getCurrentPosition(
            position => {
                plot.gps_lat = position.coords.latitude.toFixed(6);
                plot.gps_lon = position.coords.longitude.toFixed(6);
                inputs.gps_lat.value = plot.gps_lat;
                inputs.gps_lon.value = plot.gps_lon;
                dbPut("units", p);
            },
            error => {
                alert(`GPS Error: ${error.message}`);
            },
            { enableHighAccuracy: true }
        );
    };

    const card = createEl("div", { className: "card" },
      ...Object.values(inputs),
      createEl("div", { className: "actions" },
        createEl("button", {
          textContent: "Trees",
          onclick: () => setView({view:"trees", pid:p.id, plotId:plot.id})
        }),
        createEl("button", {
          className: "danger",
          textContent: "Delete",
          onclick: () => {
            if(confirm("Delete plot?")) {
              p.plots = p.plots.filter(x => x.id !== plot.id);
              dbPut("units", p).then(render);
            }
          }
        }),
        createEl("button", { className: "secondary", textContent: "Get GPS", onclick: getGPS })
      )
    );
    app.appendChild(card);
  });

  const add = createEl("button", { textContent: "+ Add Plot", onclick: () => {
    p.plots.push({id:uid(), name:"", trees:[], planned_lat: "", planned_lon: "", gps_lat: "", gps_lon: ""});
    dbPut("units", p);
    render();
  }});
  app.appendChild(add);
}

/* ============================================================
   Designs
============================================================ */
async function renderDesigns() {
  title.textContent = "Sample Designs";
  const p = await dbGet("units", nav.id);

  const debouncedSave = debounce(() => dbPut("units", p), 500);

  (p.designs || []).forEach(design => {
    const codeInput = createEl("input", { placeholder: "Code", value: design.code });
    const methodInput = createEl("input", { placeholder: "Sample Method", value: design.method });
    const sizeInput = createEl("input", { placeholder: "Sample Size", value: design.size });
    const descTextarea = createEl("textarea", { placeholder: "Description", textContent: design.description });

    const onInput = () => {
      design.code = codeInput.value;
      design.method = methodInput.value;
      design.size = sizeInput.value;
      design.description = descTextarea.value;
      debouncedSave();
    };
    codeInput.oninput = methodInput.oninput = sizeInput.oninput = descTextarea.oninput = onInput;

    const card = createEl("div", { className: "card" },
      createEl("div", { className: "form-row" }, 
        codeInput, methodInput, sizeInput
      ), descTextarea,
      createEl("div", { className: "actions" },
        createEl("button", {
          className: "danger",
          textContent: "Delete",
          onclick: () => {
            if(confirm("Delete design?")) {
              p.designs = p.designs.filter(d => d.id !== design.id);
              dbPut("units", p).then(render);
            }
          }
        })
      )
    );
    app.appendChild(card);
  });

  const add = createEl("button", { textContent: "+ Add Design", onclick: () => {
    if (!p.designs) p.designs = [];
    p.designs.push({id:uid(), code:"", method:"", size:"", description:""});
    dbPut("units", p).then(render);
  }});
  app.appendChild(add);
}

/* ============================================================
   Spreadsheet Trees
============================================================ */
async function renderTrees() {
  title.textContent = "Trees";
  const p = await dbGet("units", nav.pid);
  const plot = p.plots.find(pl=>pl.id===nav.plotId);

  const debouncedSave = debounce(() => dbPut("units", p), 500);

  const table = createEl("table", {},
    createEl("tr", {},
      ...["#", "Species", "DBH", "Ht", "Design", "Logs", "❌"].map(h => createEl("th", {}, h))
    )
  );

  plot.trees.forEach(tree => {
    const row = createEl("tr");
    const treeData = { number: tree.number, species: tree.species, dbh: tree.dbh, height: tree.height};

    for (const key in treeData) {
      const cell = createEl("td", { textContent: treeData[key], contentEditable: true, "data-key": key });
      cell.onblur = () => {
        tree[cell.dataset.key] = cell.textContent;
        debouncedSave();
      };
      row.appendChild(cell);
    }

    const designSelect = createEl("select");
    designSelect.append(createEl("option", {value: "", textContent: ""}));
    (p.designs || []).forEach(d => {
        designSelect.append(createEl("option", {value: d.code, textContent: d.code, selected: tree.designCode === d.code}));
    });
    designSelect.onchange = () => {
        tree.designCode = designSelect.value;
        debouncedSave();
    };

    row.appendChild(
        createEl("td", {}, designSelect)
    );


    row.append(
      createEl("td", {}, createEl("button", { textContent: "Logs", onclick: () => setView({view:"logs", pid:p.id, plotId:plot.id, treeId:tree.id}) })),
      createEl("td", {}, createEl("button", { className: "danger", textContent: "X", onclick: () => {
        if (confirm("Delete tree?")) {
            plot.trees = plot.trees.filter(t => t.id !== tree.id);
            dbPut("units", p).then(render);
        }
      }}))
    );
    table.appendChild(row);
  });

  const add = createEl("button", { textContent: "+ Add Tree", onclick: () => {
    plot.trees.push({id:uid(), number:"", species:"", dbh:"", height:"", designCode: "", logs:[]});
    dbPut("units", p);
    render();
  }});

  app.append(table, add);
}

/* ============================================================
   Spreadsheet Logs
============================================================ */
async function renderLogs() {
  title.textContent = "Logs";
  const p = await dbGet("units", nav.pid);
  const plot = p.plots.find(pl=>pl.id===nav.plotId);
  const tree = plot.trees.find(t=>t.id===nav.treeId);

  const debouncedSave = debounce(() => dbPut("units", p), 500);

  const table = createEl("table", {},
    createEl("tr", {},
      ...["#", "Length", "Dia", "Grade", "❌"].map(h => createEl("th", {}, h))
    )
  );

  tree.logs.forEach(log=>{
    const row = createEl("tr");
    const logData = { number: log.number, length: log.length, diameter: log.diameter, grade: log.grade };

    for (const key in logData) {
        const cell = createEl("td", { textContent: logData[key], contentEditable: true, "data-key": key });
        cell.onblur = () => {
            log[cell.dataset.key] = cell.textContent;
            debouncedSave();
        };
        row.appendChild(cell);
    }

    row.appendChild(
      createEl("td", {}, createEl("button", { className: "danger", textContent: "X", onclick: () => {
        if (confirm("Delete log?")) {
            tree.logs = tree.logs.filter(l => l.id !== log.id);
            dbPut("units", p).then(render);
        }
      }}))
    );
    table.appendChild(row);
  });

  const add = createEl("button", { textContent: "+ Add Log", onclick: () => {
    tree.logs.push({id:uid(),number:"",length:"",diameter:"",grade:""});
    dbPut("units", p);
    render();
  }});

  app.append(table,add);
}

/* ============================================================
   Export
============================================================ */
function exportJSON(unit) {
  download(JSON.stringify(unit,null,2), "unit.json");
}

function exportCSV(unit) {
  let rows=["unit,project,plot,tree,log,species,dbh,height,design,length,diameter,grade"];
  (unit.plots || []).forEach(pl=>{
    (pl.trees || []).forEach(t=>{
      if (t.logs && t.logs.length > 0) {
        t.logs.forEach(l=>{
          rows.push([unit.name,unit.project_name,pl.name,t.number,l.number,t.species,t.dbh,t.height,t.designCode,l.length,l.diameter,l.grade].join(","));
        });
      } else {
        // Include trees that have no logs
        rows.push([unit.name,unit.project_name,pl.name,t.number,"",t.species,t.dbh,t.height,t.designCode,"","",""].join(","));
      }
    });
  });
  download(rows.join("\n"),"inventory.csv");
}

function download(text,name){
  const a=document.createElement("a");
  a.href=URL.createObjectURL(new Blob([text]));
  a.download=name;
  a.click();
}

/* ============================================================
   Init
============================================================ */
openDB().then(render);
</script>
</body>
</html>
